#include "s_iic.h"
#include "system/delay/delay.h"

//初始化IIC
void IIC_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;      //普通输出模式
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;     //推挽输出
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; //100MHz
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;       //上拉

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); //使能GPIOB时钟
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;             //GPIO初始化设置
  GPIO_Init(GPIOA, &GPIO_InitStructure);                //初始化

  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE); //使能GPIOB时钟
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;             //GPIO初始化设置
  GPIO_Init(GPIOC, &GPIO_InitStructure);                //初始化

  IIC_SCL = 1;
  IIC_SDA = 1;
}
//产生IIC起始信号
void IIC_Start(void)
{
  SDA_OUT(); //sda线输出
  IIC_SDA = 1;
  IIC_SCL = 1;
  delay_us(1);
  IIC_SDA = 0; //START:when CLK is high,DATA change form high to low
  delay_us(1);
  IIC_SCL = 0; //钳住I2C总线，准备发送或接收数据
}
//产生IIC停止信号
void IIC_Stop(void)
{
  SDA_OUT(); //sda线输出
  IIC_SCL = 0;
  IIC_SDA = 0; //STOP:when CLK is high DATA change form low to high
  delay_us(1);
  IIC_SCL = 1;
  IIC_SDA = 1; //发送I2C总线结束信号
  delay_us(1);
}
//等待应答信号到来
//返回值：1，接收应答失败
//        0，接收应答成功
u8 IIC_Wait_Ack(void)
{
  u8 ucErrTime = 0;
  SDA_IN(); //SDA设置为输入
  IIC_SDA = 1;
  delay_us(1);
  IIC_SCL = 1;
  delay_us(1);
  while (READ_SDA)
  {
    ucErrTime++;
    if (ucErrTime > 250)
    {
      IIC_Stop();
      return 1;
    }
  }
  IIC_SCL = 0; //时钟输出0
  return 0;
}
//产生ACK应答
void IIC_Ack(void)
{
  IIC_SCL = 0;
  SDA_OUT();
  IIC_SDA = 0;
  delay_us(1);
  IIC_SCL = 1;
  delay_us(1);
  IIC_SCL = 0;
}
//不产生ACK应答
void IIC_NAck(void)
{
  IIC_SCL = 0;
  SDA_OUT();
  IIC_SDA = 1;
  delay_us(1);
  IIC_SCL = 1;
  delay_us(1);
  IIC_SCL = 0;
}
//IIC发送一个字节
//返回从机有无应答
//1，有应答
//0，无应答
void IIC_Send_Byte(u8 txd)
{
  u8 t;
  SDA_OUT();
  IIC_SCL = 0; //拉低时钟开始数据传输
  for (t = 0; t < 8; t++)
  {
    IIC_SDA = (txd & 0x80) >> 7;
    txd <<= 1;
    delay_us(1); //对TEA5767这三个延时都是必须的
    IIC_SCL = 1;
    delay_us(1);
    IIC_SCL = 0;
    delay_us(1);
  }
}
//读1个字节，ack=1时，发送ACK，ack=0，发送nACK
u8 IIC_Read_Byte(unsigned char ack)
{
  unsigned char i, receive = 0;
  SDA_IN(); //SDA设置为输入
  for (i = 0; i < 8; i++)
  {
    IIC_SCL = 0;
    delay_us(1);
    IIC_SCL = 1;
    receive <<= 1;
    if (READ_SDA)
      receive++;
    delay_us(1);
  }
  if (!ack)
    IIC_NAck(); //发送nACK
  else
    IIC_Ack(); //发送ACK
  return receive;
}

/**
*	@brief: 软件i2c写一个字节
*/
uint8_t IIC_WriteByte(uint8_t i2cAddr, uint8_t reg, uint8_t *data)
{
  IIC_Start();
  IIC_Send_Byte(i2cAddr & 0xfe);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 1;
  }
  IIC_Send_Byte(reg);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 2;
  }
  IIC_Send_Byte(*data);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 3;
  }
  IIC_Stop();
  return 0;
}

/**
*	@brief: 软件i2c读一个字节
*/
uint8_t IIC_ReadByte(uint8_t i2cAddr, uint8_t reg, uint8_t *data)
{
  IIC_Start();
  IIC_Send_Byte(i2cAddr & 0xfe);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 1;
  }
  IIC_Send_Byte(reg);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 2;
  }
  IIC_Start();
  IIC_Send_Byte(i2cAddr | 0x01);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 3;
  }
  *data = IIC_Read_Byte(0);
  IIC_Stop();
  return 0;
}

/**
*	@brief: 软件i2c写N字节
*/
uint8_t IIC_WriteNByte(uint8_t i2cAddr, uint8_t reg, uint8_t *data, uint16_t len)
{
  IIC_Start();
  IIC_Send_Byte(i2cAddr & 0xfe);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 1;
  }
  IIC_Send_Byte(reg);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 2;
  }
  for (; len > 0; len--)
  {
    IIC_Send_Byte(*data++);
    if (IIC_Wait_Ack() != 0)
    {
      IIC_Stop();
      return 3;
    }
  }
  IIC_Stop();
  return 0;
}

/**
*	@brief: 软件i2c读N字节
*/
uint8_t IIC_ReadNByte(uint8_t i2cAddr, uint8_t reg, uint8_t *data, uint16_t len)
{
  uint8_t ack;
  IIC_Start();
  IIC_Send_Byte(i2cAddr & 0xfe);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 1;
  }
  IIC_Send_Byte(reg);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 2;
  }
  IIC_Start();
  IIC_Send_Byte(i2cAddr | 0x01);
  if (IIC_Wait_Ack() != 0)
  {
    IIC_Stop();
    return 3;
  }
  for (; len > 0; len--)
  {
    if (len == 0)
      ack = 0;
    else
      ack = 1;
    *data++ = IIC_Read_Byte(ack);
  }
  IIC_Stop();
  return 0;
}
